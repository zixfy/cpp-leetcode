// ç»™ä½ ä¸€ä¸ª n ä¸ªç‚¹çš„ ç®€å•æœ‰å‘å›¾ ï¼ˆæ²¡æœ‰é‡å¤è¾¹çš„æœ‰å‘å›¾ï¼‰ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º 0 åˆ° n - 1
// ã€‚å¦‚æœè¿™äº›è¾¹æ˜¯åŒå‘è¾¹ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾å½¢æˆä¸€æ£µ æ ‘ ã€‚
//
//  ç»™ä½ ä¸€ä¸ªæ•´æ•° n å’Œä¸€ä¸ª äºŒç»´ æ•´æ•°æ•°ç»„ edges ï¼Œå…¶ä¸­ edges[i] = [ui, vi]
//  è¡¨ç¤ºä»èŠ‚ç‚¹ ui åˆ°èŠ‚ç‚¹ vi æœ‰ä¸€æ¡ æœ‰å‘è¾¹ ã€‚
//
//
//  è¾¹åè½¬ æŒ‡çš„æ˜¯å°†ä¸€æ¡è¾¹çš„æ–¹å‘åè½¬ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€æ¡ä»èŠ‚ç‚¹ ui åˆ°èŠ‚ç‚¹ vi
//  çš„è¾¹ä¼šå˜ä¸ºä¸€æ¡ä»èŠ‚ç‚¹ vi åˆ°èŠ‚ç‚¹ ui çš„è¾¹ã€‚
//
//  å¯¹äºèŒƒå›´ [0, n - 1] ä¸­çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ i ï¼Œä½ çš„ä»»åŠ¡æ˜¯åˆ†åˆ« ç‹¬ç«‹ è®¡ç®— æœ€å°‘
//  éœ€è¦å¤šå°‘æ¬¡ è¾¹åè½¬ ï¼Œä»èŠ‚ç‚¹ i å‡ºå‘ç»è¿‡ ä¸€ç³»åˆ—æœ‰å‘è¾¹ ï¼Œå¯ä»¥åˆ°
// è¾¾æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚
//
//  è¯·ä½ è¿”å›ä¸€ä¸ªé•¿åº¦ä¸º n çš„æ•´æ•°æ•°ç»„ answer ï¼Œå…¶ä¸­ answer[i]è¡¨ç¤ºä»èŠ‚ç‚¹ i
//  å‡ºå‘ï¼Œå¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹çš„ æœ€å°‘è¾¹åè½¬ æ¬¡æ•°ã€‚
//
//
//
//  ç¤ºä¾‹ 1ï¼š
//
//
//
//
// è¾“å…¥ï¼šn = 4, edges = [[2,0],[2,1],[1,3]]
// è¾“å‡ºï¼š[1,1,0,2]
// è§£é‡Šï¼šä¸Šå›¾è¡¨ç¤ºäº†ä¸è¾“å…¥å¯¹åº”çš„ç®€å•æœ‰å‘å›¾ã€‚
// å¯¹äºèŠ‚ç‚¹ 0 ï¼šåè½¬ [2,0] ï¼Œä»èŠ‚ç‚¹ 0 å‡ºå‘å¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[0] = 1 ã€‚
// å¯¹äºèŠ‚ç‚¹ 1 ï¼šåè½¬ [2,1] ï¼Œä»èŠ‚ç‚¹ 1 å‡ºå‘å¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[1] = 1 ã€‚
// å¯¹äºèŠ‚ç‚¹ 2 ï¼šä¸éœ€è¦åè½¬å°±å¯ä»¥ä»èŠ‚ç‚¹ 2 å‡ºå‘åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[2] = 0 ã€‚
// å¯¹äºèŠ‚ç‚¹ 3 ï¼šåè½¬ [1,3] å’Œ [2,1] ï¼Œä»èŠ‚ç‚¹ 3 å‡ºå‘å¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[3] = 2 ã€‚
//
//
//  ç¤ºä¾‹ 2ï¼š
//
//
//
//
// è¾“å…¥ï¼šn = 3, edges = [[1,2],[2,0]]
// è¾“å‡ºï¼š[2,0,1]
// è§£é‡Šï¼šä¸Šå›¾è¡¨ç¤ºäº†ä¸è¾“å…¥å¯¹åº”çš„ç®€å•æœ‰å‘å›¾ã€‚
// å¯¹äºèŠ‚ç‚¹ 0 ï¼šåè½¬ [2,0] å’Œ [1,2] ï¼Œä»èŠ‚ç‚¹ 0 å‡ºå‘å¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[0] = 2 ã€‚
// å¯¹äºèŠ‚ç‚¹ 1 ï¼šä¸éœ€è¦åè½¬å°±å¯ä»¥ä»èŠ‚ç‚¹ 2 å‡ºå‘åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[1] = 0 ã€‚
// å¯¹äºèŠ‚ç‚¹ 2 ï¼šåè½¬ [1,2] ï¼Œä»èŠ‚ç‚¹ 2 å‡ºå‘å¯ä»¥åˆ°è¾¾æ‰€æœ‰èŠ‚ç‚¹ã€‚
// æ‰€ä»¥ answer[2] = 1 ã€‚
//
//
//
//
//  æç¤ºï¼š
//
//
//  2 <= n <= 10âµ
//  edges.length == n - 1
//  edges[i].length == 2
//  0 <= ui == edges[i][0] < n
//  0 <= vi == edges[i][1] < n
//  ui != vi
//  è¾“å…¥ä¿è¯å¦‚æœè¾¹æ˜¯åŒå‘è¾¹ï¼Œå¯ä»¥å¾—åˆ°ä¸€æ£µæ ‘ã€‚
//
//
//  Related Topics æ·±åº¦ä¼˜å…ˆæœç´¢ å¹¿åº¦ä¼˜å…ˆæœç´¢ å›¾ åŠ¨æ€è§„åˆ’ ğŸ‘ 13 ğŸ‘ 0

// leetcode submit region begin(Prohibit modification and deletion)
#include "queue"
#include "vector"
using namespace std;

class Solution {
public:
  vector<int> minEdgeReversals(int n, vector<vector<int>> &edges) {
    vector adjs(n, vector<int>{});
    vector ans(n, 0);
    for (auto iter = edges.begin(); iter != edges.end(); ++iter)
      adjs[(*iter)[0]].emplace_back(std::distance(edges.begin(), iter)),
          adjs[(*iter)[1]].emplace_back(std::distance(edges.begin(), iter));

    int cost = 0;
    using u8 = std::uint8_t;
    std::queue<int> bfs;
    std::vector<u8> vis(n, 0);
    bfs.push(0);
    vis[0] = true;
    while (not bfs.empty()) {
      auto cur = bfs.front();
      for (auto edge_index : adjs[cur]) {
        auto &edge = edges[edge_index];
        auto is_rev = (edge[1] == cur);
        auto oth = (is_rev) ? edge[0] : edge[1];
        if (vis[oth])
          continue;
        if (is_rev) {
          cost++;
          ans[oth] = ans[cur] - 1;
        } else {
          ans[oth] = ans[cur] + 1;
        }
        bfs.emplace(oth);
        vis[oth] = true;
      }
      bfs.pop();
    }
    for (auto &num : ans)
      num += cost;

    return ans;
  }
};
// leetcode submit region end(Prohibit modification and deletion)
