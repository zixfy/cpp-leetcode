// å­˜åœ¨ä¸€æ£µæ— å‘è¿é€šæ ‘ï¼Œæ ‘ä¸­æœ‰ç¼–å·ä» 0 åˆ° n - 1 çš„ n ä¸ªèŠ‚ç‚¹ï¼Œ ä»¥åŠ n - 1 æ¡è¾¹ã€‚
//
//  ç»™ä½ ä¸€ä¸ªä¸‹æ ‡ä» 0 å¼€å§‹çš„æ•´æ•°æ•°ç»„ nums ï¼Œé•¿åº¦ä¸º n ï¼Œå…¶ä¸­ nums[i] è¡¨ç¤ºç¬¬ i
//  ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦ç»™ä½ ä¸€ä¸ªäºŒç»´æ•´æ•°æ•°ç»„ edges ï¼Œé•¿åº¦ä¸º
// n - 1 ï¼Œå…¶ä¸­ edges[i] = [ai, bi] è¡¨ç¤ºæ ‘ä¸­å­˜åœ¨ä¸€æ¡ä½äºèŠ‚ç‚¹ ai å’Œ bi ä¹‹é—´çš„è¾¹ã€‚
//
//  åˆ é™¤æ ‘ä¸­ä¸¤æ¡ ä¸åŒ
//  çš„è¾¹ä»¥å½¢æˆä¸‰ä¸ªè¿é€šç»„ä»¶ã€‚å¯¹äºä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆï¼Œå®šä¹‰å¦‚ä¸‹æ­¥éª¤ä»¥è®¡ç®—å…¶åˆ†æ•°ï¼š
//
//
//  åˆ†åˆ«è·å–ä¸‰ä¸ªç»„ä»¶ æ¯ä¸ª ç»„ä»¶ä¸­æ‰€æœ‰èŠ‚ç‚¹å€¼çš„å¼‚æˆ–å€¼ã€‚
//  æœ€å¤§ å¼‚æˆ–å€¼å’Œ æœ€å° å¼‚æˆ–å€¼çš„ å·®å€¼ å°±æ˜¯è¿™ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆçš„åˆ†æ•°ã€‚
//
//
//
//  ä¾‹å¦‚ï¼Œä¸‰ä¸ªç»„ä»¶çš„èŠ‚ç‚¹å€¼åˆ†åˆ«æ˜¯ï¼š[4,5,7]ã€[1,9] å’Œ [3,3,3] ã€‚ä¸‰ä¸ªå¼‚æˆ–å€¼åˆ†åˆ«æ˜¯ 4
//  ^ 5 ^ 7 = 6ã€1 ^ 9 = 8 å’Œ 3
//^ 3 ^ 3 = 3 ã€‚æœ€å¤§å¼‚æˆ–å€¼æ˜¯ 8 ï¼Œæœ€å°å¼‚æˆ–å€¼æ˜¯ 3 ï¼Œåˆ†æ•°æ˜¯ 8 - 3 = 5 ã€‚
//
//
//  è¿”å›åœ¨ç»™å®šæ ‘ä¸Šæ‰§è¡Œä»»æ„åˆ é™¤è¾¹æ–¹æ¡ˆå¯èƒ½çš„ æœ€å° åˆ†æ•°ã€‚
//
//
//
//  ç¤ºä¾‹ 1ï¼š
//  è¾“å…¥ï¼šnums = [1,5,5,4,11], edges = [[0,1],[1,2],[1,3],[3,4]]
// è¾“å‡ºï¼š9
// è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
//- ç¬¬ 1 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [1,3,4] ï¼Œå€¼æ˜¯ [5,4,11] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 ^ 4 ^ 11 = 10 ã€‚
//- ç¬¬ 2 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [0] ï¼Œå€¼æ˜¯ [1] ã€‚å¼‚æˆ–å€¼æ˜¯ 1 = 1 ã€‚
//- ç¬¬ 3 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [2] ï¼Œå€¼æ˜¯ [5] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 = 5 ã€‚
// åˆ†æ•°æ˜¯æœ€å¤§å¼‚æˆ–å€¼å’Œæœ€å°å¼‚æˆ–å€¼çš„å·®å€¼ï¼Œ10 - 1 = 9 ã€‚
// å¯ä»¥è¯æ˜ä¸å­˜åœ¨åˆ†æ•°æ¯” 9 å°çš„åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
//
//
//  ç¤ºä¾‹ 2ï¼š
//  è¾“å…¥ï¼šnums = [5,5,2,4,4,2], edges = [[0,1],[1,2],[5,2],[4,3],[1,3]]
// è¾“å‡ºï¼š0
// è§£é‡Šï¼šä¸Šå›¾å±•ç¤ºäº†ä¸€ç§åˆ é™¤è¾¹æ–¹æ¡ˆã€‚
//- ç¬¬ 1 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [3,4] ï¼Œå€¼æ˜¯ [4,4] ã€‚å¼‚æˆ–å€¼æ˜¯ 4 ^ 4 = 0 ã€‚
//- ç¬¬ 2 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [1,0] ï¼Œå€¼æ˜¯ [5,5] ã€‚å¼‚æˆ–å€¼æ˜¯ 5 ^ 5 = 0 ã€‚
//- ç¬¬ 3 ä¸ªç»„ä»¶çš„èŠ‚ç‚¹æ˜¯ [2,5] ï¼Œå€¼æ˜¯ [2,2] ã€‚å¼‚æˆ–å€¼æ˜¯ 2 ^ 2 = 0 ã€‚
// åˆ†æ•°æ˜¯æœ€å¤§å¼‚æˆ–å€¼å’Œæœ€å°å¼‚æˆ–å€¼çš„å·®å€¼ï¼Œ0 - 0 = 0 ã€‚
// æ— æ³•è·å¾—æ¯” 0 æ›´å°çš„åˆ†æ•° 0 ã€‚
//
//
//
//
//  æç¤ºï¼š
//
//
//  n == nums.length
//  3 <= n <= 1000
//  1 <= nums[i] <= 10â¸
//  edges.length == n - 1
//  edges[i].length == 2
//  0 <= ai, bi < n
//  ai != bi
//  edges è¡¨ç¤ºä¸€æ£µæœ‰æ•ˆçš„æ ‘
//
//
//  Related Topics ä½è¿ç®— æ ‘ æ·±åº¦ä¼˜å…ˆæœç´¢ æ•°ç»„ ğŸ‘ 38 ğŸ‘ 0

#include <bits/stdc++.h>
using namespace std;
// leetcode submit region begin(Prohibit modification and deletion)
class Solution {
public:
  int minimumScore(vector<int> &nums, vector<vector<int>> &edges) {
    const auto n = nums.size();
    vector adjs(n, vector<int>{});
    vector sumy(n, 0);
    for (const auto &edge : edges) {
      auto u = edge[0], v = edge[1];
      adjs[u].emplace_back(v), adjs[v].emplace_back(u);
    }
    auto dfs1 =
        [dfs_impl = [&adjs, &sumy, &nums](auto &&self, int cur, int par) -> int {
          auto ret = nums[cur];
          for (auto child : adjs[cur])
            if (child != par)
              ret ^= self(self, child, cur);
          return sumy[cur] = ret;
        }](auto &&...args) {
          return dfs_impl(dfs_impl, std::forward<decltype(args)>(args)...);
        };
    dfs1(0, -1);
    int ans = sumy[0];
    auto dfs2 =
        [dfs_impl = [&adjs, &sumy, &nums](auto &&self, int cur, int par) -> int {

          return sumy[cur] = ret;
        }](auto &&...args) {
          return dfs_impl(dfs_impl, std::forward<decltype(args)>(args)...);
        };
    dfs2(0, -1);

    std::copy(sumy.begin(), sumy.end(), ostream_iterator<int>(cout, ", "));
    return 0;
  }
};
// leetcode submit region end(Prohibit modification and deletion)
